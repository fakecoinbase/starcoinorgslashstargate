// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proof.proto

package types

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type AccumulatorProof struct {
	// The siblings. The ones near the leaf are at the beginning of the list. The
	// placeholder nodes are represented by empty byte arrays, other nodes should
	// be exactly 32-bytes long.
	Siblings             [][]byte `protobuf:"bytes,1,rep,name=siblings,proto3" json:"siblings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccumulatorProof) Reset()         { *m = AccumulatorProof{} }
func (m *AccumulatorProof) String() string { return proto.CompactTextString(m) }
func (*AccumulatorProof) ProtoMessage()    {}
func (*AccumulatorProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{0}
}

func (m *AccumulatorProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccumulatorProof.Unmarshal(m, b)
}
func (m *AccumulatorProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccumulatorProof.Marshal(b, m, deterministic)
}
func (m *AccumulatorProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatorProof.Merge(m, src)
}
func (m *AccumulatorProof) XXX_Size() int {
	return xxx_messageInfo_AccumulatorProof.Size(m)
}
func (m *AccumulatorProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatorProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatorProof proto.InternalMessageInfo

func (m *AccumulatorProof) GetSiblings() [][]byte {
	if m != nil {
		return m.Siblings
	}
	return nil
}

type SparseMerkleProof struct {
	// This proof can be used to authenticate whether a given leaf exists in the
	// tree or not. In Rust:
	//   - If this is `Some(HashValue, HashValue)`
	//     - If the first `HashValue` equals requested key, this is an inclusion
	//       proof and the second `HashValue` equals the hash of the
	//       corresponding account blob.
	//     - Otherwise this is a non-inclusion proof. The first `HashValue` is
	//       the only key that exists in the subtree and the second `HashValue`
	//       equals the hash of the corresponding account blob.
	//   - If this is `None`, this is also a non-inclusion proof which indicates
	//     the subtree is empty.
	//
	// In protobuf, this leaf field should either be
	//   - empty, which corresponds to None in the Rust structure.
	//   - exactly 64 bytes, which corresponds to Some<(HashValue, HashValue)>
	//     in the Rust structure.
	Leaf []byte `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// The siblings. The ones near the leaf are at the beginning of the list. The
	// placeholder nodes are represented by empty byte arrays, other nodes should
	// be exactly 32-bytes long.
	Siblings             [][]byte `protobuf:"bytes,2,rep,name=siblings,proto3" json:"siblings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SparseMerkleProof) Reset()         { *m = SparseMerkleProof{} }
func (m *SparseMerkleProof) String() string { return proto.CompactTextString(m) }
func (*SparseMerkleProof) ProtoMessage()    {}
func (*SparseMerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{1}
}

func (m *SparseMerkleProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SparseMerkleProof.Unmarshal(m, b)
}
func (m *SparseMerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SparseMerkleProof.Marshal(b, m, deterministic)
}
func (m *SparseMerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseMerkleProof.Merge(m, src)
}
func (m *SparseMerkleProof) XXX_Size() int {
	return xxx_messageInfo_SparseMerkleProof.Size(m)
}
func (m *SparseMerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseMerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_SparseMerkleProof proto.InternalMessageInfo

func (m *SparseMerkleProof) GetLeaf() []byte {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *SparseMerkleProof) GetSiblings() [][]byte {
	if m != nil {
		return m.Siblings
	}
	return nil
}

type AccumulatorConsistencyProof struct {
	// The root hashes of the subtrees that represent new leaves. Note that none
	// of these hashes should be default hash.
	Subtrees             [][]byte `protobuf:"bytes,1,rep,name=subtrees,proto3" json:"subtrees,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccumulatorConsistencyProof) Reset()         { *m = AccumulatorConsistencyProof{} }
func (m *AccumulatorConsistencyProof) String() string { return proto.CompactTextString(m) }
func (*AccumulatorConsistencyProof) ProtoMessage()    {}
func (*AccumulatorConsistencyProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{2}
}

func (m *AccumulatorConsistencyProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccumulatorConsistencyProof.Unmarshal(m, b)
}
func (m *AccumulatorConsistencyProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccumulatorConsistencyProof.Marshal(b, m, deterministic)
}
func (m *AccumulatorConsistencyProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatorConsistencyProof.Merge(m, src)
}
func (m *AccumulatorConsistencyProof) XXX_Size() int {
	return xxx_messageInfo_AccumulatorConsistencyProof.Size(m)
}
func (m *AccumulatorConsistencyProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatorConsistencyProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatorConsistencyProof proto.InternalMessageInfo

func (m *AccumulatorConsistencyProof) GetSubtrees() [][]byte {
	if m != nil {
		return m.Subtrees
	}
	return nil
}

type AccumulatorRangeProof struct {
	// The siblings on the left of the path from root to the first leaf. The ones
	// near the leaf are at the beginning of the list. The placeholder nodes are
	// represented by empty byte arrays, other nodes should be exactly 32-bytes
	// long.
	LeftSiblings [][]byte `protobuf:"bytes,1,rep,name=left_siblings,json=leftSiblings,proto3" json:"left_siblings,omitempty"`
	// The siblings on the right of the path from root to the last leaf. The ones
	// near the leaf are at the beginning of the list. The placeholder nodes are
	// represented by empty byte arrays, other nodes should be exactly 32-bytes
	// long.
	RightSiblings        [][]byte `protobuf:"bytes,2,rep,name=right_siblings,json=rightSiblings,proto3" json:"right_siblings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccumulatorRangeProof) Reset()         { *m = AccumulatorRangeProof{} }
func (m *AccumulatorRangeProof) String() string { return proto.CompactTextString(m) }
func (*AccumulatorRangeProof) ProtoMessage()    {}
func (*AccumulatorRangeProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{3}
}

func (m *AccumulatorRangeProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccumulatorRangeProof.Unmarshal(m, b)
}
func (m *AccumulatorRangeProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccumulatorRangeProof.Marshal(b, m, deterministic)
}
func (m *AccumulatorRangeProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatorRangeProof.Merge(m, src)
}
func (m *AccumulatorRangeProof) XXX_Size() int {
	return xxx_messageInfo_AccumulatorRangeProof.Size(m)
}
func (m *AccumulatorRangeProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatorRangeProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatorRangeProof proto.InternalMessageInfo

func (m *AccumulatorRangeProof) GetLeftSiblings() [][]byte {
	if m != nil {
		return m.LeftSiblings
	}
	return nil
}

func (m *AccumulatorRangeProof) GetRightSiblings() [][]byte {
	if m != nil {
		return m.RightSiblings
	}
	return nil
}

// The complete proof used to authenticate a transaction.
type TransactionProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo  `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}          `json:"-"`
	XXX_unrecognized                 []byte            `json:"-"`
	XXX_sizecache                    int32             `json:"-"`
}

func (m *TransactionProof) Reset()         { *m = TransactionProof{} }
func (m *TransactionProof) String() string { return proto.CompactTextString(m) }
func (*TransactionProof) ProtoMessage()    {}
func (*TransactionProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{4}
}

func (m *TransactionProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionProof.Unmarshal(m, b)
}
func (m *TransactionProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionProof.Marshal(b, m, deterministic)
}
func (m *TransactionProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionProof.Merge(m, src)
}
func (m *TransactionProof) XXX_Size() int {
	return xxx_messageInfo_TransactionProof.Size(m)
}
func (m *TransactionProof) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionProof.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionProof proto.InternalMessageInfo

func (m *TransactionProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *TransactionProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

// The complete proof used to authenticate an account state.
type AccountStateProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof  `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo   `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	TransactionInfoToAccountProof    *SparseMerkleProof `protobuf:"bytes,3,opt,name=transaction_info_to_account_proof,json=transactionInfoToAccountProof,proto3" json:"transaction_info_to_account_proof,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}           `json:"-"`
	XXX_unrecognized                 []byte             `json:"-"`
	XXX_sizecache                    int32              `json:"-"`
}

func (m *AccountStateProof) Reset()         { *m = AccountStateProof{} }
func (m *AccountStateProof) String() string { return proto.CompactTextString(m) }
func (*AccountStateProof) ProtoMessage()    {}
func (*AccountStateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{5}
}

func (m *AccountStateProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccountStateProof.Unmarshal(m, b)
}
func (m *AccountStateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccountStateProof.Marshal(b, m, deterministic)
}
func (m *AccountStateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountStateProof.Merge(m, src)
}
func (m *AccountStateProof) XXX_Size() int {
	return xxx_messageInfo_AccountStateProof.Size(m)
}
func (m *AccountStateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountStateProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccountStateProof proto.InternalMessageInfo

func (m *AccountStateProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *AccountStateProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

func (m *AccountStateProof) GetTransactionInfoToAccountProof() *SparseMerkleProof {
	if m != nil {
		return m.TransactionInfoToAccountProof
	}
	return nil
}

// The complete proof used to authenticate an event.
type EventProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo  `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	TransactionInfoToEventProof      *AccumulatorProof `protobuf:"bytes,3,opt,name=transaction_info_to_event_proof,json=transactionInfoToEventProof,proto3" json:"transaction_info_to_event_proof,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}          `json:"-"`
	XXX_unrecognized                 []byte            `json:"-"`
	XXX_sizecache                    int32             `json:"-"`
}

func (m *EventProof) Reset()         { *m = EventProof{} }
func (m *EventProof) String() string { return proto.CompactTextString(m) }
func (*EventProof) ProtoMessage()    {}
func (*EventProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{6}
}

func (m *EventProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventProof.Unmarshal(m, b)
}
func (m *EventProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventProof.Marshal(b, m, deterministic)
}
func (m *EventProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventProof.Merge(m, src)
}
func (m *EventProof) XXX_Size() int {
	return xxx_messageInfo_EventProof.Size(m)
}
func (m *EventProof) XXX_DiscardUnknown() {
	xxx_messageInfo_EventProof.DiscardUnknown(m)
}

var xxx_messageInfo_EventProof proto.InternalMessageInfo

func (m *EventProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *EventProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

func (m *EventProof) GetTransactionInfoToEventProof() *AccumulatorProof {
	if m != nil {
		return m.TransactionInfoToEventProof
	}
	return nil
}

// The complete proof used to authenticate a list of transactions.
type TransactionListProof struct {
	LedgerInfoToTransactionInfosProof *AccumulatorRangeProof `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_infos_proof,json=ledgerInfoToTransactionInfosProof,proto3" json:"ledger_info_to_transaction_infos_proof,omitempty"`
	TransactionInfos                  []*TransactionInfo     `protobuf:"bytes,2,rep,name=transaction_infos,json=transactionInfos,proto3" json:"transaction_infos,omitempty"`
	XXX_NoUnkeyedLiteral              struct{}               `json:"-"`
	XXX_unrecognized                  []byte                 `json:"-"`
	XXX_sizecache                     int32                  `json:"-"`
}

func (m *TransactionListProof) Reset()         { *m = TransactionListProof{} }
func (m *TransactionListProof) String() string { return proto.CompactTextString(m) }
func (*TransactionListProof) ProtoMessage()    {}
func (*TransactionListProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{7}
}

func (m *TransactionListProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionListProof.Unmarshal(m, b)
}
func (m *TransactionListProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionListProof.Marshal(b, m, deterministic)
}
func (m *TransactionListProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionListProof.Merge(m, src)
}
func (m *TransactionListProof) XXX_Size() int {
	return xxx_messageInfo_TransactionListProof.Size(m)
}
func (m *TransactionListProof) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionListProof.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionListProof proto.InternalMessageInfo

func (m *TransactionListProof) GetLedgerInfoToTransactionInfosProof() *AccumulatorRangeProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfosProof
	}
	return nil
}

func (m *TransactionListProof) GetTransactionInfos() []*TransactionInfo {
	if m != nil {
		return m.TransactionInfos
	}
	return nil
}

func init() {
	proto.RegisterType((*AccumulatorProof)(nil), "types.AccumulatorProof")
	proto.RegisterType((*SparseMerkleProof)(nil), "types.SparseMerkleProof")
	proto.RegisterType((*AccumulatorConsistencyProof)(nil), "types.AccumulatorConsistencyProof")
	proto.RegisterType((*AccumulatorRangeProof)(nil), "types.AccumulatorRangeProof")
	proto.RegisterType((*TransactionProof)(nil), "types.TransactionProof")
	proto.RegisterType((*AccountStateProof)(nil), "types.AccountStateProof")
	proto.RegisterType((*EventProof)(nil), "types.EventProof")
	proto.RegisterType((*TransactionListProof)(nil), "types.TransactionListProof")
}

func init() { proto.RegisterFile("proof.proto", fileDescriptor_473d204b28f447f0) }

var fileDescriptor_473d204b28f447f0 = []byte{
	// 419 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x94, 0x41, 0x8e, 0xd3, 0x30,
	0x14, 0x86, 0x95, 0x14, 0x10, 0x7a, 0x6d, 0x21, 0x8d, 0xa0, 0x44, 0x2d, 0x88, 0x36, 0xa8, 0xa8,
	0xab, 0x2c, 0x60, 0xc5, 0xb2, 0xaa, 0x58, 0x20, 0x81, 0x84, 0xd2, 0x6e, 0x51, 0xe4, 0x04, 0x27,
	0x8d, 0x08, 0x76, 0x64, 0x3b, 0x23, 0xf5, 0x26, 0x73, 0x80, 0xb9, 0xc7, 0x5c, 0x60, 0x0e, 0x35,
	0x8a, 0xed, 0x99, 0x24, 0xce, 0x74, 0x66, 0xdd, 0x5d, 0xdf, 0xb3, 0xdf, 0xff, 0xff, 0xef, 0x53,
	0x1d, 0x18, 0x96, 0x8c, 0xd2, 0x34, 0x28, 0x19, 0x15, 0xd4, 0x7d, 0x2e, 0x8e, 0x25, 0xe6, 0xb3,
	0xa9, 0x60, 0x88, 0x70, 0x94, 0x88, 0x9c, 0x92, 0x28, 0x27, 0x29, 0x55, 0xc7, 0x7e, 0x00, 0xce,
	0x26, 0x49, 0xaa, 0xff, 0x55, 0x81, 0x04, 0x65, 0xbf, 0xeb, 0x41, 0x77, 0x06, 0x2f, 0x79, 0x1e,
	0x17, 0x39, 0xc9, 0xb8, 0x67, 0x2d, 0x06, 0xeb, 0x51, 0x78, 0x5f, 0xfb, 0x5b, 0x98, 0xec, 0x4a,
	0xc4, 0x38, 0xfe, 0x85, 0xd9, 0xbf, 0x02, 0xab, 0x01, 0x17, 0x9e, 0x15, 0x18, 0xa5, 0x9e, 0xb5,
	0xb0, 0xd6, 0xa3, 0x50, 0xfe, 0xee, 0x88, 0xd8, 0x86, 0xc8, 0x37, 0x98, 0xb7, 0x4c, 0xb7, 0x94,
	0xf0, 0x9c, 0x0b, 0x4c, 0x92, 0x63, 0xe3, 0x5f, 0xc5, 0x82, 0x61, 0xdc, 0xf8, 0xeb, 0xda, 0x4f,
	0xe0, 0x6d, 0x6b, 0x34, 0x44, 0x24, 0xd3, 0x19, 0x3e, 0xc1, 0xb8, 0xc0, 0xa9, 0x88, 0x8c, 0xe4,
	0xa3, 0xba, 0xb9, 0xd3, 0x3d, 0x77, 0x05, 0xaf, 0x58, 0x9e, 0x1d, 0x5a, 0xb7, 0x54, 0xb4, 0xb1,
	0xec, 0xde, 0x5d, 0xf3, 0xaf, 0x2d, 0x70, 0xf6, 0x0d, 0x2f, 0x65, 0x70, 0x80, 0x55, 0x81, 0xff,
	0x66, 0x98, 0x49, 0x7c, 0x91, 0xa0, 0x91, 0x89, 0x34, 0x92, 0xdc, 0x25, 0x85, 0xe1, 0x97, 0x77,
	0x81, 0x04, 0x1f, 0x98, 0x74, 0xc3, 0x85, 0x52, 0xf9, 0x41, 0x52, 0xba, 0xa7, 0x2d, 0x97, 0xba,
	0xa1, 0x9c, 0x36, 0xe0, 0x98, 0xd2, 0x9e, 0x2d, 0x45, 0xa7, 0x5a, 0xd4, 0x18, 0x0b, 0x5f, 0x8b,
	0x6e, 0xc3, 0xbf, 0xb2, 0x61, 0xb2, 0x49, 0x12, 0x5a, 0x11, 0xb1, 0x13, 0x48, 0xe0, 0xf3, 0x5b,
	0xc1, 0x8d, 0x61, 0xd9, 0x4b, 0x27, 0x68, 0x84, 0xd4, 0x56, 0x3a, 0xe8, 0x40, 0x6a, 0x7a, 0x5a,
	0xb3, 0xf7, 0xcf, 0x0c, 0x3f, 0x18, 0xaa, 0x7b, 0xaa, 0xa9, 0xc8, 0x63, 0xff, 0xd2, 0x06, 0xf8,
	0x7e, 0x81, 0x75, 0x79, 0x5e, 0x7c, 0xfe, 0xc0, 0xc7, 0x87, 0xf8, 0xe0, 0x7a, 0x9d, 0x0e, 0x9d,
	0x93, 0x31, 0xe7, 0x3d, 0x38, 0x0d, 0x0b, 0xff, 0xc6, 0x82, 0x37, 0xad, 0x0c, 0x3f, 0x73, 0xae,
	0x21, 0x51, 0xf8, 0xfc, 0x04, 0x24, 0xde, 0xa1, 0xf4, 0xbe, 0x6f, 0xdf, 0x3c, 0xdb, 0x70, 0xf9,
	0x08, 0x2a, 0xae, 0x0c, 0xb7, 0x30, 0xe9, 0x39, 0xc8, 0x77, 0x7b, 0x1a, 0x96, 0x63, 0x6c, 0xc6,
	0xe3, 0x17, 0xf2, 0x73, 0xf7, 0xf5, 0x36, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x63, 0xb7, 0xa0, 0x1c,
	0x05, 0x00, 0x00,
}
